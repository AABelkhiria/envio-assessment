# RTOS Intertask Communication

### Contents
---

- [Questions](#questions)
- [Answers](#answers)

### Questions
---
You are writing a firmware application for MCU (any `ARM Cortex MCU`). Your application needs to poll data from a sensor and do some processing with the data. Your application is based on `RTOS` (e.g. freeRTOS) and have 2 tasks (threads): 

- `POLLING task`

- `PROCESSING task`

**POLLING** task is regularly polling data from a sensor, and stores information locally, while the **PROCESSING** task needs to take that data and process it. Two tasks are operating with different speed and they need to be synchronized. 

```
- How would you implement the intertask communication model?
```
```
- What other task synchronization techniques do you know?
```

### Answers
---

Without knowing the exact timings, data lengths and types, it is really hard to suggest one best method for this model. But below is the list of possible solutions for possible cases for the given case.

1. Although not suggested; If an atomic Read/Write is possible (e.g. the data length is small enough for the MCU to do the Read/Write operation in one cycle), the easiest way is to use increase the scope of the shared data (by using `global variables` or wrappers to `static variables`)

2. If an atomic Read/Write is not possible, the second easiest way is to use a flag to let the other tasks know that the variable is ready to be read. Since the Read/Write on the flag will be atomic, the reader tasks can check the flag and know that the variable is not in use and can be readable. 

These two methods above can work in some situations depending on the context, but it is better to use the tools provided by the RTOS so that it will be meaningfull to have a real time operating system, the OS can handle intertask communications and thread-safe operations if the right tools are used.

For the given specifications, `Mailboxes` and `Binary Semaphores` looks like the best match. The job of the Processing Task always depends on the data generated by the Polling Task. If there is no new data entry, then the Processing Task has no job to do. In this case:

3. The Processing Task should `Pend` on the `Mailbox` that is `Post`ed by the Polling Task. When the Polling Task posts the Mailbox, the operating system will set the Processing Task to the running state.

4. If the tasks are scheduled to be running in a periodic manner or the Polling Task decides when to run the ProcessingTask (e.g. sufficient number of data entries were put to the buffer), instead of using a Mailbox, we can directly use a `Binary Semaphore` to let the two tasks access to the `shared resource`.

Here is a simplified example usage of a Semaphore:

```C
xSemaphoreHandle ProcessSignal = 0;

void PollingTaskFunction(...)
{
    for(;;)
    {
        //Poll the data
        xSemaphoreGive(ProcessSignal);
        vTaskDelay(1000);	//or any event to schedule the task speed
    }
}

void ProcessingTaskFunction(...)
{
    for(;;)
    {
        /* The Processing Task will be sleep until the Polling Task Function gives the Semaphore */
        if(vSemaphoreTake(ProcessSignal, portMAX_DELAY))
        {
            //Process the data
        }
    }
}
```

5. If the Polling task polls for a flag that is set by an ISR to understand that the sensor data is ready to be read, we can save this time space by running the Processing Task during the time slots where the Polling Task is doing nothing. We can achieve this by suspending the Polling Task while the data ready flag is not set and resuming it back from the ISR by using the `xTaskResumeFromISR` function.


Below is a simlified implementation. When the Processing Task completes processing the data, it will suspend itself and then wait forever until some other task/ISR resumes it back. Similarly, the Polling Task suspends itself after reading the data and resumes the Processing Task. This method can be impractical depending on the timings, if the ISR period is faster than the speed of the data reading in the Polling Task, it can cause an interrupt loss.

```C
void DmaFullCompleteISR(void)
{
    BaseType_t xYieldRequired;

    xYieldRequired = xTaskResumeFromISR(&PollingTaskHandle);
    
    if(xYieldRequired == pdTRUE)
    {
        taskYIELD();
    }
}

void PollingTaskFunction(...) /* Priority 1 */ 
{
    for(;;)
    {
        //Sensor data is ready. Read it and resume the Processing Task.
		vTaskResume(xHandle);
		vTaskSuspend(NULL);
    }
}

void ProcessingTaskFunction(...) /* Priority 2 */
{
    for(;;)
    {
        //Process the data
		vTaskSuspend(NULL);
    }
}
```






